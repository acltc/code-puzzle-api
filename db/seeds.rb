Puzzle.create!([
  {name: "Word Count", instructions: "For example for the input \"olly olly in come free\"\n\nolly: 2\nin: 1\ncome: 1\nfree: 1\n\n", language: "Ruby", test_code: "require 'minitest/autorun'\nrequire_relative 'phrase'\n\nclass PhraseTest < MiniTest::Unit::TestCase\n\n  def test_count_one_word\n    phrase = Phrase.new(\"word\")\n    counts = {\"word\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_one_of_each\n    skip\n    phrase = Phrase.new(\"one of each\")\n    counts = {\"one\" => 1, \"of\" => 1, \"each\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_multiple_occurrences\n    skip\n    phrase = Phrase.new(\"one fish two fish red fish blue fish\")\n    counts = {\"one\" => 1, \"fish\" => 4, \"two\" => 1, \"red\" => 1, \"blue\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_count_everything_just_once\n    skip\n    phrase = Phrase.new(\"all the kings horses and all the kings men\")\n    phrase.word_count # count it an extra time\n    counts = {\n      \"all\" => 2, \"the\" => 2, \"kings\" => 2, \"horses\" => 1, \"and\" => 1, \"men\" => 1\n    }\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_ignore_punctuation\n    skip\n    phrase = Phrase.new(\"car : carpet as java : javascript!!&@$%^&\")\n    counts = {\"car\" => 1, \"carpet\" => 1, \"as\" => 1, \"java\" => 1, \"javascript\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_handles_cramped_lists\n    skip\n    phrase = Phrase.new(\"one,two,three\")\n    counts = {\"one\" => 1, \"two\" => 1, \"three\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_include_numbers\n    skip\n    phrase = Phrase.new(\"testing, 1, 2 testing\")\n    counts = {\"testing\" => 2, \"1\" => 1, \"2\" => 1}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_normalize_case\n    skip\n    phrase = Phrase.new(\"go Go GO\")\n    counts = {\"go\" => 3}\n    assert_equal counts, phrase.word_count\n  end\n\n  def test_with_apostrophes\n    skip\n    phrase = Phrase.new(\"First: don't laugh. Then: don't cry.\")\n    counts = {\"first\"=>1, \"don't\"=>2, \"laugh\"=>1, \"then\"=>1, \"cry\"=>1}\n    assert_equal counts, phrase.word_count\n  end\nend"},
  {name: "Hamming", instructions: "A mutation is simply a mistake that occurs during the creation or copying of a nucleic acid, in particular DNA. Because nucleic acids are vital to cellular functions, mutations tend to cause a ripple effect throughout the cell. Although mutations are technically mistakes, a very rare mutation may equip the cell with a beneficial attribute. In fact, the macro effects of evolution are attributable by the accumulated result of beneficial microscopic mutations over many generations.\n\nThe simplest and most common type of nucleic acid mutation is a point mutation, which replaces one base with another at a single nucleotide.\n\nBy counting the number of differences between two homologous DNA strands taken from different genomes with a common ancestor, we get a measure of the minimum number of point mutations that could have occurred on the evolutionary path between the two strands.\n\nThis is called the 'Hamming distance'\n\n    GAGCCTACTAACGGGAT\n    CATCGTAATGACGGCCT\n    ^ ^ ^  ^ ^    ^^\n\nThe Hamming distance between these two DNA strands is 7.\n", language: "Ruby", test_code: "require 'minitest/autorun'\nrequire_relative 'hamming'\n\nclass HammingTest < MiniTest::Unit::TestCase\n  def test_no_difference_between_identical_strands\n    assert_equal 0, Hamming.compute('A', 'A')\n  end\n\n  def test_complete_hamming_distance_of_for_single_nucleotide_strand\n    skip\n    assert_equal 1, Hamming.compute('A','G')\n  end\n\n  def test_complete_hamming_distance_of_for_small_strand\n    skip\n    assert_equal 2, Hamming.compute('AG','CT')\n  end\n\n  def test_small_hamming_distance\n    skip\n    assert_equal 1, Hamming.compute('AT','CT')\n  end\n\n  def test_small_hamming_distance_in_longer_strand\n    skip\n    assert_equal 1, Hamming.compute('GGACG', 'GGTCG')\n  end\n\n  def test_ignores_extra_length_on_first_strand_when_longer\n    skip\n    assert_equal 1, Hamming.compute('AGAGACTTA', 'AAA')\n  end\n\n  def test_ignores_extra_length_on_other_strand_when_longer\n    skip\n    assert_equal 2, Hamming.compute('AGG', 'AAAACTGACCCACCCCAGG')\n  end\n\n  def test_large_hamming_distance\n    skip\n    assert_equal 4, Hamming.compute('GATACA', 'GCATAA')\n  end\n\n  def test_hamming_distance_in_very_long_strand\n    skip\n    assert_equal 9, Hamming.compute('GGACGGATTCTG', 'AGGACGGATTCT')\n  end\nend"},
  {name: "Anagrams", instructions: "Given \"listen\" and a list of candidates like \"enlists\" \"google\" \"inlets\" \"banana\" the program should return a list containing \"inlets\".", language: "Ruby", test_code: "require 'minitest/autorun'\nrequire_relative 'anagram'\n\nclass AnagramTest < MiniTest::Unit::TestCase\n\n  def test_no_matches\n    detector = Anagram.new('diaper')\n    assert_equal [], detector.match(%w(hello world zombies pants))\n  end\n\n  def test_detect_simple_anagram\n    skip\n    detector = Anagram.new('ant')\n    anagrams = detector.match(['tan', 'stand', 'at'])\n    assert_equal ['tan'], anagrams\n  end\n\n  def test_detect_multiple_anagrams\n    skip\n    detector = Anagram.new('master')\n    anagrams = detector.match(['stream', 'pigeon', 'maters'])\n    assert_equal ['maters', 'stream'], anagrams.sort\n  end\n\n  def test_does_not_confuse_different_duplicates\n    skip\n    detector = Anagram.new('galea')\n    assert_equal [], detector.match(['eagle'])\n  end\n\n  def test_identical_word_is_not_anagram\n    skip\n    detector = Anagram.new('corn')\n    anagrams = detector.match %w(corn dark Corn rank CORN cron park)\n    assert_equal ['cron'], anagrams\n  end\n\n  def test_eliminate_anagrams_with_same_checksum\n    skip\n    detector = Anagram.new('mass')\n    assert_equal [], detector.match(['last'])\n  end\n\n  def test_eliminate_anagram_subsets\n    skip\n    detector = Anagram.new('good')\n    assert_equal [], detector.match(['dog', 'goody'])\n  end\n\n  def test_detect_anagram\n    skip\n    detector = Anagram.new('listen')\n    anagrams = detector.match %w(enlists google inlets banana)\n    assert_equal ['inlets'], anagrams\n  end\n\n  def test_multiple_anagrams\n    skip\n    detector = Anagram.new('allergy')\n    anagrams = detector.match %w(gallery ballerina regally clergy largely leading)\n    assert_equal ['gallery', 'largely', 'regally'], anagrams.sort\n  end\n\n  def test_anagrams_are_case_insensitive\n    skip\n    detector = Anagram.new('Orchestra')\n    anagrams = detector.match %w(cashregister Carthorse radishes)\n    assert_equal ['Carthorse'], anagrams\n  end\nend"}
])
